Index: main/src/main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* \n * Copyright 2021 University of Toronto\n *\n * Permission is hereby granted, to use this software and associated \n * documentation files (the \"Software\") in course work at the University \n * of Toronto, or for personal use. Other uses are prohibited, in \n * particular the distribution of the Software either publicly or to third \n * parties.\n *\n * The above copyright notice and this permission notice shall be included in \n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n#include <iostream>\n#include <string>\n\n#include \"m1.h\"\n\n//Program exit codes\nconstexpr int SUCCESS_EXIT_CODE = 0;        //Everyting went OK\nconstexpr int ERROR_EXIT_CODE = 1;          //An error occured\nconstexpr int BAD_ARGUMENTS_EXIT_CODE = 2;  //Invalid command-line usage\n\n//The default map to load if none is specified\nstd::string default_map_path = \"/cad2/ece297s/public/maps/toronto_canada.streets.bin\";\n\n\n// The start routine of your program (main) when you are running your standalone\n// mapper program. This main routine is *never called* when you are running \n// ece297exercise (the unit tests) -- those tests have their own main routine\n// and directly call your functions in /libstreetmap/src/ to test them.\n// Don't write any code in this file that you want run by ece297exerise -- it \n// will not be called!\nint main(int argc, char** argv) {\n\n    std::string map_path;\n    if(argc == 1) {\n        //Use a default map\n        map_path = default_map_path;\n    } else if (argc == 2) {\n        //Get the map from the command line\n        map_path = argv[1];\n    } else {\n        //Invalid arguments\n        std::cerr << \"Usage: \" << argv[0] << \" [map_file_path]\\n\";\n        std::cerr << \"  If no map_file_path is provided a default map is loaded.\\n\";\n        return BAD_ARGUMENTS_EXIT_CODE;\n    }\n\n    //Load the map and related data structures\n    bool load_success = loadMap(map_path);\n    if(!load_success) {\n        std::cerr << \"Failed to load map '\" << map_path << \"'\\n\";\n        return ERROR_EXIT_CODE;\n    }\n\n    std::cout << \"Successfully loaded map '\" << map_path << \"'\\n\";\n\n    //You can now do something with the map data\n\n\n    //Clean-up the map data and related data structures\n    std::cout << \"Closing map\\n\";\n    closeMap(); \n\n    return SUCCESS_EXIT_CODE;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main/src/main.cpp b/main/src/main.cpp
--- a/main/src/main.cpp	(revision 3ea9c0f5c8865d6184b6657cde44ae0ee158dfd7)
+++ b/main/src/main.cpp	(date 1613146453651)
@@ -64,7 +64,9 @@
     std::cout << "Successfully loaded map '" << map_path << "'\n";
 
     //You can now do something with the map data
+    double ans = findStreetSegmentLength(124726);
 
+    std::cout << ans << std::endl;
 
     //Clean-up the map data and related data structures
     std::cout << "Closing map\n";
Index: libstreetmap/src/m1.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* \n * Copyright 2021 University of Toronto\n *\n * Permission is hereby granted, to use this software and associated \n * documentation files (the \"Software\") in course work at the University \n * of Toronto, or for personal use. Other uses are prohibited, in \n * particular the distribution of the Software either publicly or to third \n * parties.\n *\n * The above copyright notice and this permission notice shall be included in \n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <iostream>\n#include <cmath> // gain access to math constants and functions such as M_PI\n#include \"m1.h\"\n#include \"StreetsDatabaseAPI.h\"\n#include \"LatLon.h\" // required to use the Latlon parameters (Latitude and longitdue)\n#include <algorithm>\n#include <utility>\n#include \"TrieNode.h\"\n#include <vector>\n#include <map>\n\n#define RADIUS_OF_EARTH 6371000\n\n// loadMap will be called with the name of the file that stores the \"layer-2\"\n// map data accessed through StreetsDatabaseAPI: the street and intersection \n// data that is higher-level than the raw OSM data). \n// This file name will always end in \".streets.bin\" and you \n// can call loadStreetsDatabaseBIN with this filename to initialize the\n// layer 2 (StreetsDatabase) API.\n// If you need data from the lower level, layer 1, API that provides raw OSM\n// data (nodes, ways, etc.) you will also need to initialize the layer 1 \n// OSMDatabaseAPI by calling loadOSMDatabaseBIN. That function needs the \n// name of the \".osm.bin\" file that matches your map -- just change \n// \".streets\" to \".osm\" in the map_streets_database_filename to get the proper\n// name.\n\nint numOfStreets;\nstd::string *streetNames;\nstruct TrieNode *root; //root for streetnames trie\n\ndouble degToRad(double degree);//helper to convert degrees to radians\n\nstd::vector<std::vector<std::string>> street_names_of_intersection; //stores the street names for each intersection\n//Includes repetition!!\nstd::vector<std::vector<IntersectionIdx>> intersections_of_a_street;\n\nstd::vector<std::vector<StreetSegmentIdx>> segments_of_an_intersection;\n\nstd::vector<std::vector<IntersectionIdx>> adjacent_intersections;\n\nstd::vector<std::vector<std::pair<StreetIdx, StreetIdx>>> intersections_of_two_streets;\n\nbool loadMap(std::string map_streets_database_filename) {\n    bool load_successful = loadStreetsDatabaseBIN(\n            map_streets_database_filename); //Indicates whether the map has loaded successfully\n\n    std::cout << \"loadMap: \" << map_streets_database_filename << std::endl;\n\n    if (load_successful) {\n        numOfStreets = getNumStreets();\n        streetNames = new std::string[numOfStreets]; //container to store streetnames\n\n        for (int i = 0; i < numOfStreets; i++) { //formatting and storing street names w/o spaces and all lowercase\n            streetNames[i] = getStreetName(i);\n            streetNames[i].erase(std::remove(streetNames[i].begin(), streetNames[i].end(), ' '), streetNames[i].end());\n            std::transform(streetNames[i].begin(), streetNames[i].end(), streetNames[i].begin(),\n                           [](unsigned char c) { return std::tolower(c); });\n        }\n\n        root = makeNode(); //creating root for trie\n\n        for (int i = 0; i < numOfStreets; i++) { //inputs all streetnames and indices into the trie\n            insertToTrie(root, streetNames[i], i);\n        }\n\n        segments_of_an_intersection.resize(getNumIntersections());\n\n        street_names_of_intersection.resize(getNumIntersections());\n\n        intersections_of_a_street.resize(getNumStreets());\n\n        intersections_of_two_streets.resize(getNumStreets());\n\n        adjacent_intersections.resize(getNumIntersections());\n\n        for (int intersection = 0; intersection < getNumIntersections(); intersection++) {\n            for (int segment = 0; segment < getNumIntersectionStreetSegment(intersection); segment++) {\n                int streetSeg_id = getIntersectionStreetSegment(intersection, segment);\n                segments_of_an_intersection[intersection].push_back(streetSeg_id);\n\n                /*FINDING THE STREET NAMES THAT PASS THROUGH AN INTERSECTION*/\n                //gets the street id of a specific segment\n                StreetIdx street_ID_of_segment = getStreetSegmentInfo(streetSeg_id).streetID;\n                //stores the name at specified street id in th street names function\n                street_names_of_intersection[intersection].push_back(getStreetName(street_ID_of_segment));\n\n                /*FINDING INTERSECTIONS OF A STREET*/\n                ///if the intersection does not exists on the list of intersections of a street, then add it\n                if (!(std::find(intersections_of_a_street[street_ID_of_segment].begin(),\n                                intersections_of_a_street[street_ID_of_segment].end(), intersection) !=\n                      intersections_of_a_street[street_ID_of_segment].end())) {\n                    intersections_of_a_street[street_ID_of_segment].push_back(intersection);\n                }\n\n\n\n                /*FINDING ADJACENT INTERSECTIONS*/\n                /*logic: since each segment has one \"from\" and one \"to\" intersection ids,\n                 * then as we loop through the segments we can check if the current intersection\n                 * is the \"from\" or the \"to\" of the segment\n                 * if it is the \"from\", then we add the \"to\" of the segment to it's adjacent intersections\n                 * if it's the to, we move on to the next segment\n                 * This will allow each intersection to be added only once to another intersection's adjacent list\n                 * while only going in a direction that fits one way streets */\n\n                //check if the current intersection  is the \"from\" intersection\n                if (intersection == getStreetSegmentInfo(segment).from) {\n                    //add the \"to\" intersection to the adjacent intersections of the current intersection\n                    adjacent_intersections[intersection].push_back(getStreetSegmentInfo(segment).to);\n                }\n\n\n            }\n        }\n        for (StreetIdx first_street_idx = 0; first_street_idx < getNumStreets(); first_street_idx++) {\n            for (int intersection = 0;\n                 intersection < intersections_of_a_street[first_street_idx].size(); intersection++) {\n                for (int segment = 0; segment < segments_of_an_intersection[intersection].size(); segment++) {\n                    StreetIdx second_street_idx = getStreetSegmentInfo(\n                            segments_of_an_intersection[intersection][segment]).streetID;\n                    if (first_street_idx != second_street_idx) {\n                        std::pair<StreetIdx, StreetIdx> original_id_pair(first_street_idx, second_street_idx);\n                        std::pair<StreetIdx, StreetIdx> reverse_id_pair(second_street_idx, first_street_idx);\n                        if (std::find(intersections_of_two_streets[first_street_idx].begin(),\n                                      intersections_of_two_streets[first_street_idx].end(), original_id_pair) !=\n                            intersections_of_two_streets[first_street_idx].end()) {\n                            if (std::find(intersections_of_two_streets[first_street_idx].begin(),\n                                          intersections_of_two_streets[first_street_idx].end(), reverse_id_pair) !=\n                                intersections_of_two_streets[first_street_idx].end()) {\n                                intersections_of_two_streets[first_street_idx].push_back(original_id_pair);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return load_successful;\n\n    }\n}\n\nvoid closeMap() {\n    //Clean-up your map related data structures here\n    closeStreetDatabase();\n\n    std::vector<std::vector<std::string>> GARBAGE_street_names_of_intersection;\n    street_names_of_intersection.swap(GARBAGE_street_names_of_intersection);\n\n    std::vector<std::vector<IntersectionIdx>> GARBAGE_intersections_of_a_street;\n    intersections_of_a_street.swap(GARBAGE_intersections_of_a_street);\n\n    std::vector<std::vector<StreetSegmentIdx>> GARBAGE_segments_of_an_intersection;\n    segments_of_an_intersection.swap(GARBAGE_segments_of_an_intersection);\n\n    std::vector<std::vector<IntersectionIdx>> GARBAGE_adjacent_intersections;\n    adjacent_intersections.swap(GARBAGE_adjacent_intersections);\n\n    std::vector<std::vector<std::pair<StreetIdx, StreetIdx>>> GARBAGE_intersections_of_two_streets;\n    intersections_of_two_streets.swap(GARBAGE_intersections_of_two_streets);\n\n\n    delete[] streetNames;\n\n\n    destroyTrie(root);//dealloc trie\n\n}\n\ndouble degToRad(double degree) {//convert degrees to radians\n    return (((M_PI) / 180) * degree);\n}\n\n// Returns the nearest point of interest of the given name to the given position\n// Speed Requirement --> none \nPOIIdx findClosestPOI(LatLon my_position, std::string POIname) {\n    double smallestDistance = 99999999999;\n    double distanceToCurrentPOI = 0;\n    int totalNumOfPOI = getNumPointsOfInterest();\n    POIIdx closestPOIIdx = -1;\n\n    for (int i = 0; i < totalNumOfPOI; i++) {\n        if (getPOIName(i) == POIname) {\n            distanceToCurrentPOI = findDistanceBetweenTwoPoints(std::make_pair(my_position, getPOIPosition(i)));\n\n            if (distanceToCurrentPOI <\n                smallestDistance) { //stores value of smallest distance and the POI index for it\n                smallestDistance = distanceToCurrentPOI;\n                closestPOIIdx = i;\n            }\n        }\n    }\n    return closestPOIIdx;\n}\n\n// Returns the area of the given closed feature in square meters\n// Assume a non self-intersecting polygon (i.e. no holes)\n// Return 0 if this feature is not a closed polygon.\n// Speed Requirement --> moderate\ndouble findFeatureArea(FeatureIdx feature_id) {\n    double area = 0;\n    double yMax = -999999;\n    double avgLat = 0;\n\n    int numOfPoints = getNumFeaturePoints(feature_id);//finds number of points on the feature\n\n    LatLon *featurePoints = new LatLon[numOfPoints];\n\n    for (int i = 0; i < numOfPoints; i++) {\n        featurePoints[i] = getFeaturePoint(feature_id, i);//creates array of featurePoints\n        avgLat += degToRad(featurePoints[i].latitude());\n    }\n\n    avgLat = avgLat / numOfPoints;\n\n    double *x = new double[numOfPoints];\n    double *y = new double[numOfPoints];\n    double radLat, radLong;\n\n    for (int i = 0; i < numOfPoints; i++) {\n        radLat = degToRad(featurePoints[i].latitude());\n        radLong = degToRad(featurePoints[i].longitude());\n\n        x[i] = RADIUS_OF_EARTH * radLong * cos(avgLat);\n        y[i] = RADIUS_OF_EARTH * radLat;\n\n        if (y[i] > yMax) yMax = y[i];\n    }\n    if (x[0] == x[numOfPoints - 1] && y[0] == y[numOfPoints - 1]) {\n        for (int i = 0; i < numOfPoints; i++) {\n            if (i == numOfPoints - 1) {\n                area += x[i] * y[0] - y[i] * x[0];\n            } else {\n                area += x[i] * y[i + 1] - y[i] * x[i + 1];\n            }\n        }\n        area = fabs(area / 2);\n\n        delete[] x;\n        delete[] y;\n        delete[] featurePoints;\n\n        return area;\n    } else {\n        delete[] x;\n        delete[] y;\n        delete[] featurePoints;\n\n        return 0;\n    }\n}\n\nstd::vector<StreetIdx> findStreetIdsFromPartialStreetName(std::string street_prefix) {\n    street_prefix.erase(std::remove(street_prefix.begin(), street_prefix.end(), ' '), street_prefix.end());\n    std::transform(street_prefix.begin(), street_prefix.end(), street_prefix.begin(),\n                   [](unsigned char c) { return std::tolower(c); });\n\n    return findStreetName(root, street_prefix);\n}\n\ndouble findDistanceBetweenTwoPoints(std::pair<LatLon, LatLon> points) {\n    // Converting latitude and longitudes from degrees to radians\n    double lat1 = kDegreeToRadian * (points.first.latitude());\n    double long1 = kDegreeToRadian * (points.first.longitude());\n    double lat2 = kDegreeToRadian * (points.second.latitude());\n    double long2 = kDegreeToRadian * (points.second.longitude());\n\n    double latAvg = (lat2 + lat1) / 2;\n    double x1 = long1 * (cos(latAvg));\n    double x2 = long2 * (cos(latAvg));\n    double y1 = lat1;\n    double y2 = lat2;\n    double diffinY = y2 - y1;\n    double diffinX = x2 - x1;\n\n    double power1 = pow(diffinY, 2);\n    double power2 = pow(diffinX, 2);\n    double distance = kEarthRadiusInMeters * (sqrt(power1 + power2));\n    return distance;\n}\n\nLatLonBounds findStreetBoundingBox(StreetIdx street_id) {\n    LatLonBounds stub;\n    return stub;\n}\n\ndouble findStreetLength(StreetIdx street_id) {\n    double stub;\n    return stub;\n}\n\ndouble findStreetSegmentLength(StreetSegmentIdx street_segment_id) {\n    //case if no curve points exist\n    double length = 0;\n    IntersectionIdx from = getStreetSegmentInfo(street_segment_id).from;\n    IntersectionIdx to = getStreetSegmentInfo(street_segment_id).to;\n    int numOfCurvePoints = getStreetSegmentInfo(street_segment_id).numCurvePoints;\n    if (numOfCurvePoints == 0) {\n        std::pair<LatLon, LatLon> point;\n        point = std::make_pair(getIntersectionPosition(from), getIntersectionPosition(to));\n        length = findDistanceBetweenTwoPoints(point);\n    }\n        //case if there is only one curve point\n    else if (numOfCurvePoints == 1) {\n        std::pair<LatLon, LatLon> pair1;\n        std::pair<LatLon, LatLon> pair2;\n        pair1 = std::make_pair(getIntersectionPosition(from),\n                               getStreetSegmentCurvePoint(street_segment_id, 0));\n        pair2 = std::make_pair(getStreetSegmentCurvePoint(street_segment_id, 0),\n                               getIntersectionPosition(to));\n        length = findDistanceBetweenTwoPoints(pair1) + findDistanceBetweenTwoPoints(pair2);\n    } else {\n        LatLon previousPoint;\n        LatLon temp1 = getIntersectionPosition(from);\n        LatLon temp2 = getIntersectionPosition(to);\n        for (int i = 0; i < numOfCurvePoints; i++) {\n            if(i == 0){\n                std::pair<LatLon, LatLon> fromToFirstCurve = std::make_pair(getIntersectionPosition(from),\n                                                                            getStreetSegmentCurvePoint(street_segment_id, 0));\n                length += findDistanceBetweenTwoPoints(fromToFirstCurve);\n                previousPoint = getStreetSegmentCurvePoint(street_segment_id, 0);\n            }else if(i == numOfCurvePoints - 1){\n                std::pair<LatLon, LatLon> lastCurvePointToTo = std::make_pair(getIntersectionPosition(to), previousPoint);\n                length += findDistanceBetweenTwoPoints(lastCurvePointToTo);\n            }else{\n                std::pair<LatLon, LatLon> curveToCurve = std::make_pair(getStreetSegmentCurvePoint(street_segment_id, i), previousPoint);\n                length += findDistanceBetweenTwoPoints(curveToCurve);\n                previousPoint = getStreetSegmentCurvePoint(street_segment_id, i);\n            }\n        }\n    }\n    return length;\n}\n\ndouble findStreetSegmentTravelTime(StreetSegmentIdx street_segment_id) {\n    // fetch the speed limit of the segment in question\n    float speedLimit = getStreetSegmentInfo(street_segment_id).speedLimit;\n    // return the speed which is length/time\n    return findStreetSegmentLength(street_segment_id) / speedLimit;\n\n}\n\n\n\n\n//GHAMR'S FUNCTIONS////////////////////////////////////////////////////////////////////\n\n\n\n// Returns the nearest intersection to the given position\n// Speed Requirement --> none\nIntersectionIdx findClosestIntersection(LatLon my_position) {\n    IntersectionIdx stub;\n    return stub;\n}\n\n\n\n\n\n\n// Return all intersection ids at which the two given streets intersect\n// This function will typically return one intersection id for streets\n// that intersect and a length 0 vector for streets that do not. For unusual \n// curved streets it is possible to have more than one intersection at which \n// two streets cross.\n// There should be no duplicate intersections in the returned vector.\n// Speed Requirement --> high\nstd::vector<IntersectionIdx> findIntersectionsOfTwoStreets(std::pair<StreetIdx, StreetIdx> street_ids){\n\n    return {};\n}\n\n\n\n\n\n\n\n//GHAMR: DONE////////////////////////////////////////////////////////////////////////\n\n// Returns the street names at the given intersection (includes duplicate \n// street names in the returned vector)\n// Speed Requirement --> high \nstd::vector<std::string> findStreetNamesOfIntersection(IntersectionIdx intersection_id) {\n\n    return street_names_of_intersection[intersection_id];\n}\n\n// Returns the street segments that connect to the given intersection \n// Speed Requirement --> high\nstd::vector<StreetSegmentIdx> findStreetSegmentsOfIntersection(IntersectionIdx intersection_id) {\n\n    return segments_of_an_intersection[intersection_id];\n}\n\n// Returns all intersections along the a given street.\n// There should be no duplicate intersections in the returned vector.\n// Speed Requirement --> high\nstd::vector<IntersectionIdx> findIntersectionsOfStreet(StreetIdx street_id) {\n\n\n    return intersections_of_a_street[street_id];\n\n}\n\n// Returns all intersections reachable by traveling down one street segment \n// from the given intersection (hint: you can't travel the wrong way on a \n// 1-way street)\n// the returned vector should NOT contain duplicate intersections\n// Speed Requirement --> high \nstd::vector<IntersectionIdx> findAdjacentIntersections(IntersectionIdx intersection_id) {\n\n    return adjacent_intersections[intersection_id];\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libstreetmap/src/m1.cpp b/libstreetmap/src/m1.cpp
--- a/libstreetmap/src/m1.cpp	(revision 3ea9c0f5c8865d6184b6657cde44ae0ee158dfd7)
+++ b/libstreetmap/src/m1.cpp	(date 1613147327883)
@@ -287,17 +287,16 @@
     double long2 = kDegreeToRadian * (points.second.longitude());
 
     double latAvg = (lat2 + lat1) / 2;
-    double x1 = long1 * (cos(latAvg));
-    double x2 = long2 * (cos(latAvg));
-    double y1 = lat1;
-    double y2 = lat2;
+    double x1 = RADIUS_OF_EARTH* long1 * (cos(latAvg));
+    double x2 = RADIUS_OF_EARTH* long2 * (cos(latAvg));
+    double y1 = RADIUS_OF_EARTH * lat1;
+    double y2 = RADIUS_OF_EARTH* lat2;
     double diffinY = y2 - y1;
     double diffinX = x2 - x1;
 
     double power1 = pow(diffinY, 2);
     double power2 = pow(diffinX, 2);
-    double distance = kEarthRadiusInMeters * (sqrt(power1 + power2));
-    return distance;
+    return (sqrt(power1 + power2));
 }
 
 LatLonBounds findStreetBoundingBox(StreetIdx street_id) {
@@ -332,8 +331,6 @@
         length = findDistanceBetweenTwoPoints(pair1) + findDistanceBetweenTwoPoints(pair2);
     } else {
         LatLon previousPoint;
-        LatLon temp1 = getIntersectionPosition(from);
-        LatLon temp2 = getIntersectionPosition(to);
         for (int i = 0; i < numOfCurvePoints; i++) {
             if(i == 0){
                 std::pair<LatLon, LatLon> fromToFirstCurve = std::make_pair(getIntersectionPosition(from),
