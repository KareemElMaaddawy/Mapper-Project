Index: libstreetmap/src/m1.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* \n * Copyright 2021 University of Toronto\n *\n * Permission is hereby granted, to use this software and associated \n * documentation files (the \"Software\") in course work at the University \n * of Toronto, or for personal use. Other uses are prohibited, in \n * particular the distribution of the Software either publicly or to third \n * parties.\n *\n * The above copyright notice and this permission notice shall be included in \n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <iostream>\n#include <cmath> // gain access to math constants and functions such as M_PI\n#include \"m1.h\"\n#include \"StreetsDatabaseAPI.h\"\n#include \"LatLon.h\" // required to use the Latlon parameters (Latitude and longitdue)\n#include <algorithm>\n#include <utility>\n#include \"TrieNode.h\"\n#include <vector>\n#include <map>\n\n// loadMap will be called with the name of the file that stores the \"layer-2\"\n// map data accessed through StreetsDatabaseAPI: the street and intersection \n// data that is higher-level than the raw OSM data). \n// This file name will always end in \".streets.bin\" and you \n// can call loadStreetsDatabaseBIN with this filename to initialize the\n// layer 2 (StreetsDatabase) API.\n// If you need data from the lower level, layer 1, API that provides raw OSM\n// data (nodes, ways, etc.) you will also need to initialize the layer 1 \n// OSMDatabaseAPI by calling loadOSMDatabaseBIN. That function needs the \n// name of the \".osm.bin\" file that matches your map -- just change \n// \".streets\" to \".osm\" in the map_streets_database_filename to get the proper\n// name.\n\nint numOfStreets;\nstd::string *streetNames;\nstruct TrieNode *root; //root for streetnames trie\n\nint numOfStreetSegments;\ndouble *segLength;\ndouble *segTime;\n\nstd::vector<std::vector<std::string>> street_names_of_intersection; //stores the street names for each intersection\n//Includes repetition!!\nstd::vector<std::vector<IntersectionIdx>> intersections_of_a_street;\n\nstd::vector<std::vector<StreetSegmentIdx>> segments_of_an_intersection;\n\nstd::vector<std::vector<IntersectionIdx>> adjacent_intersections;\n\n\nstd::vector<StreetSegmentInfo> street_segment_info; //vector that holds info struct of each street segment\n\nstd::vector<std::vector<std::pair<StreetIdx, StreetIdx>>> intersections_of_two_streets;\n\ndouble lengthHelper(StreetSegmentIdx street_segment_id);\n\nbool loadMap(std::string map_streets_database_filename) {\n    bool load_successful = loadStreetsDatabaseBIN(\n            map_streets_database_filename); //Indicates whether the map has loaded successfully\n\n    std::cout << \"loadMap: \" << map_streets_database_filename << std::endl;\n\n    if (load_successful) {\n        numOfStreetSegments = getNumStreetSegments();\n        segLength = new double[numOfStreetSegments];\n        segTime = new double[numOfStreetSegments];\n        for(int i = 0; i < numOfStreetSegments; i++){\n            double length = lengthHelper(i);\n            segLength[i] = length;\n            segTime[i] = length / getStreetSegmentInfo(i).speedLimit;\n        }\n\n        numOfStreets = getNumStreets();\n        streetNames = new std::string[numOfStreets]; //container to store streetnames\n\n        for (int i = 0; i < numOfStreets; i++) { //formatting and storing street names w/o spaces and all lowercase\n            streetNames[i] = getStreetName(i);\n            streetNames[i].erase(std::remove(streetNames[i].begin(), streetNames[i].end(), ' '), streetNames[i].end());\n            std::transform(streetNames[i].begin(), streetNames[i].end(), streetNames[i].begin(),\n                           [](unsigned char c) { return std::tolower(c); });\n        }\n\n        root = makeNode(); //creating root for trie\n\n        for (int i = 0; i < numOfStreets; i++) { //inputs all streetnames and indices into the trie\n            insertToTrie(root, streetNames[i], i);\n        }\n\n        segments_of_an_intersection.resize(getNumIntersections());\n\n        street_names_of_intersection.resize(getNumIntersections());\n\n        intersections_of_a_street.resize(getNumStreets());\n\n        intersections_of_two_streets.resize(getNumStreets());\n\n        adjacent_intersections.resize(getNumIntersections());\n        \n        for(int i = 0; i < getNumStreetSegments(); i++){\n            street_segment_info.push_back(getStreetSegmentInfo(i)); // vector is filled with struct of info\n        }\n        \n//        for (int intersection = 0; intersection < getNumIntersections(); intersection++){\n//            for (int segment = 0; segment < getNumIntersectionStreetSegment(intersection); segment++){\n//                int streetSeg_id = getIntersectionStreetSegment(intersection, segment);\n//                segments_of_an_intersection[intersection].push_back(streetSeg_id);\n//                  \n//                /*FINDING THE STREET NAMES THAT PASS THROUGH AN INTERSECTION*/\n//                //gets the street id of a specific segment\n//                StreetIdx street_ID_of_segment = getStreetSegmentInfo(streetSeg_id).streetID;\n//                //stores the name at specified street id in th street names function\n//                street_names_of_intersection[intersection].push_back(getStreetName(street_ID_of_segment));\n//\n//                 /*FINDING INTERSECTIONS OF A STREET*/\n//                ///if the intersection does not exists on the list of intersections of a street, then add it\n//                if (!(std::find(intersections_of_a_street[street_ID_of_segment].begin(), intersections_of_a_street[street_ID_of_segment].end(), intersection) != intersections_of_a_street[street_ID_of_segment].end())){  \n//                    intersections_of_a_street[street_ID_of_segment].push_back(intersection);\n//                }\n//                \n//                 /*FINDING ADJACENT INTERSECTIONS*/\n//                 /*logic: since each segment has one \"from\" and one \"to\" intersection ids,\n//                  * then as we loop through the segments we can check if the current intersection \n//                  * is the \"from\" or the \"to\" of the segment\n//                  * if it is the \"from\", then we add the \"to\" of the segment to it's adjacent intersections\n//                  * if it's the to, we move on to the next segment\n//                  * This will allow each intersection to be added only once to another intersection's adjacent list\n//                  * while only going in a direction that fits one way streets */\n//                \n//                 //check if the current intersection  is the \"from\" intersection\n//                if(intersection == getStreetSegmentInfo(segment).from){\n//                    //add the \"to\" intersection to the adjacent intersections of the current intersection\n//                    adjacent_intersections[intersection].push_back(getStreetSegmentInfo(segment).to);\n//                }  \n//            }\n//        }\n\n        for (int intersection = 0; intersection < getNumIntersections(); intersection++) {\n            for (int segment = 0; segment < getNumIntersectionStreetSegment(intersection); segment++) {\n                int streetSeg_id = getIntersectionStreetSegment(intersection, segment);\n                segments_of_an_intersection[intersection].push_back(streetSeg_id);\n\n                /*FINDING THE STREET NAMES THAT PASS THROUGH AN INTERSECTION*/\n                //gets the street id of a specific segment\n                StreetIdx street_ID_of_segment = getStreetSegmentInfo(streetSeg_id).streetID;\n                //stores the name at specified street id in th street names function\n                street_names_of_intersection[intersection].push_back(getStreetName(street_ID_of_segment));\n\n                /*FINDING INTERSECTIONS OF A STREET*/\n                ///if the intersection does not exists on the list of intersections of a street, then add it\n                if (!(std::find(intersections_of_a_street[street_ID_of_segment].begin(),\n                                intersections_of_a_street[street_ID_of_segment].end(), intersection) !=\n                      intersections_of_a_street[street_ID_of_segment].end())) {\n                    intersections_of_a_street[street_ID_of_segment].push_back(intersection);\n                }\n\n\n\n                /*FINDING ADJACENT INTERSECTIONS*/\n                /*logic: since each segment has one \"from\" and one \"to\" intersection ids,\n                 * then as we loop through the segments we can check if the current intersection\n                 * is the \"from\" or the \"to\" of the segment\n                 * if it is the \"from\", then we add the \"to\" of the segment to it's adjacent intersections\n                 * if it's the to, we move on to the next segment\n                 * This will allow each intersection to be added only once to another intersection's adjacent list\n                 * while only going in a direction that fits one way streets */\n\n                //check if the current intersection  is the \"from\" intersection\n                if (intersection == getStreetSegmentInfo(segment).from) {\n                    //add the \"to\" intersection to the adjacent intersections of the current intersection\n                    adjacent_intersections[intersection].push_back(getStreetSegmentInfo(segment).to);\n                }\n\n\n            }\n        }\n        for (StreetIdx first_street_idx = 0; first_street_idx < getNumStreets(); first_street_idx++) {\n            for (int intersection = 0;\n                 intersection < intersections_of_a_street[first_street_idx].size(); intersection++) {\n                for (int segment = 0; segment < segments_of_an_intersection[intersection].size(); segment++) {\n                    StreetIdx second_street_idx = getStreetSegmentInfo(\n                            segments_of_an_intersection[intersection][segment]).streetID;\n                    if (first_street_idx != second_street_idx) {\n                        std::pair<StreetIdx, StreetIdx> original_id_pair(first_street_idx, second_street_idx);\n                        std::pair<StreetIdx, StreetIdx> reverse_id_pair(second_street_idx, first_street_idx);\n                        if (std::find(intersections_of_two_streets[first_street_idx].begin(),\n                                      intersections_of_two_streets[first_street_idx].end(), original_id_pair) !=\n                            intersections_of_two_streets[first_street_idx].end()) {\n                            if (std::find(intersections_of_two_streets[first_street_idx].begin(),\n                                          intersections_of_two_streets[first_street_idx].end(), reverse_id_pair) !=\n                                intersections_of_two_streets[first_street_idx].end()) {\n                                intersections_of_two_streets[first_street_idx].push_back(original_id_pair);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }return load_successful;\n}\n\nvoid closeMap() {\n    //Clean-up your map related data structures here\n    closeStreetDatabase();\n\n    std::vector<std::vector<std::string>> GARBAGE_street_names_of_intersection;\n    street_names_of_intersection.swap(GARBAGE_street_names_of_intersection);\n\n    std::vector<std::vector<IntersectionIdx>> GARBAGE_intersections_of_a_street;\n    intersections_of_a_street.swap(GARBAGE_intersections_of_a_street);\n\n    std::vector<std::vector<StreetSegmentIdx>> GARBAGE_segments_of_an_intersection;\n    segments_of_an_intersection.swap(GARBAGE_segments_of_an_intersection);\n\n    std::vector<std::vector<IntersectionIdx>> GARBAGE_adjacent_intersections;\n    adjacent_intersections.swap(GARBAGE_adjacent_intersections);\n\n    std::vector<std::vector<std::pair<StreetIdx, StreetIdx>>> GARBAGE_intersections_of_two_streets;\n    intersections_of_two_streets.swap(GARBAGE_intersections_of_two_streets);\n\n\n    delete[] streetNames;\n    delete[] segLength;\n    delete[] segTime;\n\n\n    destroyTrie(root);//dealloc trie\n\n}\n\n// Returns the nearest point of interest of the given name to the given position\n// Speed Requirement --> none \nPOIIdx findClosestPOI(LatLon my_position, std::string POIname) {\n    double smallestDistance = 99999999999;\n    double distanceToCurrentPOI = 0;\n    int totalNumOfPOI = getNumPointsOfInterest();\n    POIIdx closestPOIIdx = -1;\n\n    for (int i = 0; i < totalNumOfPOI; i++) {\n        if (getPOIName(i) == POIname) {\n            distanceToCurrentPOI = findDistanceBetweenTwoPoints(std::make_pair(my_position, getPOIPosition(i)));\n\n            if (distanceToCurrentPOI <\n                smallestDistance) { //stores value of smallest distance and the POI index for it\n                smallestDistance = distanceToCurrentPOI;\n                closestPOIIdx = i;\n            }\n        }\n    }\n    return closestPOIIdx;\n}\n\n// Returns the area of the given closed feature in square meters\n// Assume a non self-intersecting polygon (i.e. no holes)\n// Return 0 if this feature is not a closed polygon.\n// Speed Requirement --> moderate\ndouble findFeatureArea(FeatureIdx feature_id) {\n    double area = 0;\n    double yMax = -999999;\n    double avgLat = 0;\n\n    int numOfPoints = getNumFeaturePoints(feature_id);//finds number of points on the feature\n\n    LatLon *featurePoints = new LatLon[numOfPoints];\n\n    for (int i = 0; i < numOfPoints; i++) {\n        featurePoints[i] = getFeaturePoint(feature_id, i);//creates array of featurePoints\n        avgLat += kDegreeToRadian *featurePoints[i].latitude();\n    }\n\n    avgLat = avgLat / numOfPoints;\n\n    double *x = new double[numOfPoints];\n    double *y = new double[numOfPoints];\n    double radLat, radLong;\n\n    for (int i = 0; i < numOfPoints; i++) {\n        radLat = kDegreeToRadian *featurePoints[i].latitude();\n        radLong = kDegreeToRadian *featurePoints[i].longitude();\n\n        x[i] = kEarthRadiusInMeters * radLong * cos(avgLat);\n        y[i] = kEarthRadiusInMeters * radLat;\n\n        if (y[i] > yMax) yMax = y[i];\n    }\n    if (x[0] == x[numOfPoints - 1] && y[0] == y[numOfPoints - 1]) {\n        for (int i = 0; i < numOfPoints; i++) {\n            if (i == numOfPoints - 1) {\n                area += x[i] * y[0] - y[i] * x[0];\n            } else {\n                area += x[i] * y[i + 1] - y[i] * x[i + 1];\n            }\n        }\n        area = fabs(area / 2);\n\n        delete[] x;\n        delete[] y;\n        delete[] featurePoints;\n\n        return area;\n    } else {\n        delete[] x;\n        delete[] y;\n        delete[] featurePoints;\n\n        return 0;\n    }\n}\n\nstd::vector<StreetIdx> findStreetIdsFromPartialStreetName(std::string street_prefix) {\n    street_prefix.erase(std::remove(street_prefix.begin(), street_prefix.end(), ' '), street_prefix.end());\n    std::transform(street_prefix.begin(), street_prefix.end(), street_prefix.begin(),\n                   [](unsigned char c) { return std::tolower(c); });\n\n    return findStreetName(root, street_prefix);\n}\n\ndouble findDistanceBetweenTwoPoints(std::pair<LatLon, LatLon> points) {\n    // Converting latitude and longitudes from degrees to radians\n    double lat1 = kDegreeToRadian * (points.first.latitude());\n    double long1 = kDegreeToRadian * (points.first.longitude());\n    double lat2 = kDegreeToRadian * (points.second.latitude());\n    double long2 = kDegreeToRadian * (points.second.longitude());\n\n    double latAvg = (lat2 + lat1) / 2;\n\n    return (sqrt(pow(kEarthRadiusInMeters*(lat2-lat1), 2) + pow(kEarthRadiusInMeters*cos(latAvg)*(long2-long1), 2)));\n}\n\nLatLonBounds findStreetBoundingBox(StreetIdx street_id) {\n    LatLonBounds stub;\n    return stub;\n}\n\n\ndouble findStreetLength(StreetIdx street_id){\n//    double length = 0;\n//    for(int i = 0; i < street_segment_info.size() ; i++){\n//        if(street_segment_info[i].streetID == street_id){\n//            length += findStreetSegmentLength(i);\n//        }\n//    }\n    return 0;\n}\n\ndouble findStreetSegmentLength(StreetSegmentIdx street_segment_id){\n    return segLength[street_segment_id];\n}\n\ndouble lengthHelper(StreetSegmentIdx street_segment_id) {\n    //case if no curve points exist\n    double length = 0;\n    IntersectionIdx from = getStreetSegmentInfo(street_segment_id).from;\n    IntersectionIdx to = getStreetSegmentInfo(street_segment_id).to;\n    int numOfCurvePoints = getStreetSegmentInfo(street_segment_id).numCurvePoints;\n    if (numOfCurvePoints == 0) {\n        std::pair<LatLon, LatLon> point;\n        point = std::make_pair(getIntersectionPosition(from), getIntersectionPosition(to));\n        length = findDistanceBetweenTwoPoints(point);\n    }\n        //case if there is only one curve point\n    else if (numOfCurvePoints == 1) {\n        std::pair<LatLon, LatLon> pair1;\n        std::pair<LatLon, LatLon> pair2;\n        pair1 = std::make_pair(getIntersectionPosition(from),\n                               getStreetSegmentCurvePoint(street_segment_id, 0));\n        pair2 = std::make_pair(getStreetSegmentCurvePoint(street_segment_id, 0),\n                               getIntersectionPosition(to));\n        length = findDistanceBetweenTwoPoints(pair1) + findDistanceBetweenTwoPoints(pair2);\n    } else {\n        LatLon previousPoint;\n        for (int i = 0; i < numOfCurvePoints; i++) {\n            if(i == 0) {\n                std::pair<LatLon, LatLon> fromToFirstCurve = std::make_pair(getIntersectionPosition(from),\n                                                                            getStreetSegmentCurvePoint(\n                                                                                    street_segment_id, 0));\n                length += findDistanceBetweenTwoPoints(fromToFirstCurve);\n                previousPoint = getStreetSegmentCurvePoint(street_segment_id, 0);\n            }else{\n                std::pair<LatLon, LatLon> curveToCurve = std::make_pair(getStreetSegmentCurvePoint(street_segment_id, i), previousPoint);\n                length += findDistanceBetweenTwoPoints(curveToCurve);\n                previousPoint = getStreetSegmentCurvePoint(street_segment_id, i);\n            }\n        }\n        std::pair<LatLon, LatLon> lastCurvePointToTo = std::make_pair(getIntersectionPosition(to), previousPoint);\n        length += findDistanceBetweenTwoPoints(lastCurvePointToTo);\n    }\n    return length;\n}\n\ndouble findStreetSegmentTravelTime(StreetSegmentIdx street_segment_id) {\n    // return the speed which is length/time\n    return segTime[street_segment_id];\n}\n\n\n\n\n//GHAMR'S FUNCTIONS////////////////////////////////////////////////////////////////////\n\n\n\n// Returns the nearest intersection to the given position\n// Speed Requirement --> none\nIntersectionIdx findClosestIntersection(LatLon my_position) {\n    IntersectionIdx stub;\n    return stub;\n}\n\n\n\n\n\n\n// Return all intersection ids at which the two given streets intersect\n// This function will typically return one intersection id for streets\n// that intersect and a length 0 vector for streets that do not. For unusual \n// curved streets it is possible to have more than one intersection at which \n// two streets cross.\n// There should be no duplicate intersections in the returned vector.\n// Speed Requirement --> high\nstd::vector<IntersectionIdx> findIntersectionsOfTwoStreets(std::pair<StreetIdx, StreetIdx> street_ids){\n\n    return {};\n}\n\n\n\n\n\n\n\n//GHAMR: DONE////////////////////////////////////////////////////////////////////////\n\n// Returns the street names at the given intersection (includes duplicate \n// street names in the returned vector)\n// Speed Requirement --> high \nstd::vector<std::string> findStreetNamesOfIntersection(IntersectionIdx intersection_id) {\n\n    return street_names_of_intersection[intersection_id];\n}\n\n// Returns the street segments that connect to the given intersection \n// Speed Requirement --> high\nstd::vector<StreetSegmentIdx> findStreetSegmentsOfIntersection(IntersectionIdx intersection_id) {\n\n    return segments_of_an_intersection[intersection_id];\n}\n\n// Returns all intersections along the a given street.\n// There should be no duplicate intersections in the returned vector.\n// Speed Requirement --> high\nstd::vector<IntersectionIdx> findIntersectionsOfStreet(StreetIdx street_id) {\n\n\n    return intersections_of_a_street[street_id];\n\n}\n\n// Returns all intersections reachable by traveling down one street segment \n// from the given intersection (hint: you can't travel the wrong way on a \n// 1-way street)\n// the returned vector should NOT contain duplicate intersections\n// Speed Requirement --> high \nstd::vector<IntersectionIdx> findAdjacentIntersections(IntersectionIdx intersection_id) {\n\n    return adjacent_intersections[intersection_id];\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/libstreetmap/src/m1.cpp b/libstreetmap/src/m1.cpp
--- a/libstreetmap/src/m1.cpp	(revision 5f3ac589d6a3c8a1c1e58f40dbbbacc4cf09b03e)
+++ b/libstreetmap/src/m1.cpp	(date 1613161680781)
@@ -339,7 +339,8 @@
 }
 
 LatLonBounds findStreetBoundingBox(StreetIdx street_id) {
-    LatLonBounds stub;
+    double xMin, xMax, yMin, yMax;
+
     return stub;
 }
 
